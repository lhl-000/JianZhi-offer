# 04 二维数组中的查找

### 题目

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。



### 解答


##### 1.线性查找(自己想的) (时间复杂度 O(nm) 空间复杂度 0)
```
/Java/
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }
        int maxCol = matrix[0].length;
        for (int row=0; row<matrix.length; row++) {
            for (int col=maxCol-1; col>=0; col--) {
                if (matrix[row][col] > target) {
                    maxCol = col;
                    continue;
                }
                else if (matrix[row][col] < target) {
                    continue;
                }
                else {
                    return true;
                }
            }
        }
        return false;
    }
}
```

##### 1.线性查找(官方) (时间复杂度 O(nm) 空间复杂度 0)
```
/Java/
/my code/
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }
        int maxCol = matrix[0].length;
        for (int row=0; row<matrix.length; row++) {
            for (int col=maxCol-1; col>=0; col--) {
                if (matrix[row][col] > target) {
                    maxCol = col;
                    continue;
                }
                else if (matrix[row][col] < target) {
                    continue;
                }
                else {
                    return true;
                }
            }
        }
        return false;
    }
}
/offical/
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        int rows = matrix.length, columns = matrix[0].length;
        int row = 0, column = columns - 1;
        while (row < rows && column >= 0) {
            int num = matrix[row][column];
            if (num == target) {
                return true;
            } else if (num > target) {
                column--;
            } else {
                row++;
            }
        }
        return false;
    }
}
/js/
function findNumberIn2DArray(matrix, target) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }
    var cols = matrix[0].length;
    var rows = matrix.length;
    let col = cols - 1;
    let row = 0;
    while (row < rows && col >= 0) {
        let num = matrix[row][col] ;
        if (num > target) {
            col--;
        }
        else if (num < target) {
            row++;
        }
        else{
            return true;
        }
    }
    return false;
};
/ts/
function findNumberIn2DArray(matrix: number[][], target: number): boolean {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }
    var rows:number = matrix.length;
    var cols:number = matrix[0].length;
    var row:number = 0;
    var col:number = cols - 1;
    while (row < rows && col >= 0) {
        let num:number = matrix[row][col];
        if (num > target) {
            col--;
        }
        else if (num < target) {
            row++;
        }
        else {
            return true;
        }
    }
    return false;
};
```

### 错误解答
没考虑到下一行相对上一行的增幅大小

```
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if (matrix == null) {
            return false;
        }
        boolean isReverse = false;
        for (int j=0, i=0; j<matrix.length; j++) {
            while ( i >= 0 && i <= (matrix[0].length - 1)) {
                if (isReverse) {
                    if (matrix[j][i] == target) {
                    return true;
                    }
                    else if (matrix[j][i] > target ) {
                        if (i == 0) {
                            return false;
                        }
                        i--;
                    }
                    else {
                        if (i== matrix[0].length-1) {
                            isReverse = true;
                            break;
                        }
                        if (i != 0 && matrix[j][i] == matrix[j][i-1]) {
                            i--;
                            continue;
                        }
                        isReverse = false;
                        break;
                    }
                }
                else {
                    if (matrix[j][i] == target) {
                    return true;
                    }
                    else if (matrix[j][i] < target ) {
                        if (i == matrix[0].length - 1) {
                            isReverse = true;
                            break;
                        }
                        i++;
                    }
                    else {
                        isReverse = true;
                        break;
                    }
                }
            }   
        }
        return false;
    }
}
```