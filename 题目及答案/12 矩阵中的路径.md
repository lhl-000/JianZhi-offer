# 12 矩阵中的路径

### 题目

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用

### 解答

#### 深度优先搜索
```
/*JAVA*/
class Solution {
    public boolean exist(char[][] board, String word) {
        if (board == null || board.length == 0 || board[0].length == 0 || word.length() == 0) {
            return false;
        }
        for (int col=0; col<board.length; col++) {
            for (int row=0; row < board[0].length; row++) {
                int index = 0;
                if (ds(board, word, index, col, row)) {
                    return true;
                }
            } 
        }
        return false;
    }

    public boolean ds(char[][] board, String word, int index, int col, int row) {
        if (index >= word.length() || col < 0 || col >= board.length 
        || row < 0 || row >= board[0].length 
        || board[col][row] != word.charAt(index)) {
            return false;
        }
        board[col][row] = '\0';
        if (index == word.length()-1) {
            return true;
        }
        boolean res =  ds(board, word, index + 1, col, row - 1)
            || ds(board, word, index + 1, col, row + 1)
            || ds(board, word, index + 1, col + 1, row)
            || ds(board, word, index + 1, col - 1, row);
        board[col][row] = word.charAt(index);
        return res;
    }
}
/js/
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
    if (board === null || board === undefined || board.length === 0 || board[0].length === 0 
    || word === null || word ===undefined || word.length === 0) {
        return false;
    }
    for (let j=0; j<board.length; j++) {
        for (let i=0; i<board[0].length; i++) {
            if (dfs(board, word, 0, j, i)) {
                return true;
            }
        }
    }
    return false;
};

var dfs = function(board, word, index, j, i) {
    if (j<0 || j>=board.length || i<0 || i>board[0].length || index >= word.length
        || word[index] != board[j][i]) {
        return false;
    }
    board[j][i] = '\0';
    if (index == word.length-1) {
        return true;
    }
    res = dfs(board, word, index+1, j+1, i) || dfs(board, word, index+1, j-1, i) 
        || dfs(board, word, index+1, j, i+1) || dfs(board, word, index+1, j, i-1);
    board[j][i] = word[index];
    return res;
}
```