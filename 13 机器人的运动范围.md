# 12 机器人的运动范围

### 题目

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？


### 解答

##### 1.使用 hashmap和 DFS

```
/*JAVA*/
class Solution {
    public int movingCount(int m, int n, int k) {
         Map<Integer, Integer> map = new HashMap<>();
        dfs(map, 0, 0, m, n, k);
        return map.size();
    }

    public void dfs(Map<Integer, Integer> map, int j, int i, int m, int n, int k) {
        if (j<0 || j>= m || i<0 || i>= n || countDight(j, i) > k) {
            return;
        }
        if (map.containsKey(j*100+i)) {
            return;
        }
        map.put(j*100+i, null);
        dfs (map, j+1, i, m ,n, k);
        dfs (map, j-1, i, m ,n, k);
        dfs (map, j, i+1, m ,n, k);
        dfs (map, j, i-1, m ,n, k);
    }

    public int countDight(int j , int i) {
        int sum = 0;
        while (j != 0) {
            sum += j % 10;
            j /= 10;
        }
        while (i != 0) {
            sum += i % 10;
            i /= 10;
        }
        return sum;
    }
}
/*JS*/
function findRepeatNumber(nums) {
    var set = new Set();
    for (var i of nums) {
            if (set.has(i)) {
                return i;
            }
            set.add(i);
        }
        return -1;
    }
```
#### 2.使用dfs和辅助数组

```
class Solution {
    public int movingCount(int m, int n, int k) {
        boolean[][] visted = new boolean[m][n];
        return dfs(visted, 0, 0, m, n, k);
    }

    public int dfs(boolean[][] visted, int j, int i, int m, int n, int k) {
        if (j<0 || j>= m || i<0 || i>= n || visted[j][i] || countDight(j, i) > k) {
            return 0;
        }
        visted[j][i] = true;
        return 1 + dfs (visted, j+1, i, m ,n, k) + dfs (visted, j-1, i, m ,n, k) + dfs (visted, j, i+1, m ,n, k) + dfs (visted, j, i-1, m ,n, k); 
    }

    public int countDight(int j , int i) {
        int sum = 0;
        while (j != 0) {
            sum += j % 10;
            j /= 10;
        }
        while (i != 0) {
            sum += i % 10;
            i /= 10;
        }
        return sum;
    }
}
```

#### 3.使用wfs和辅助数组
```
var movingCount = function(m, n, k) {
    let queue = [];
    let visited = new Array();
    let count = 0;
    for (let j=0; j<m; j++) {
        visited[j] = new Array();
        for (let i=0; i<n; i++) {
            visited[j][i] = false;
        }
    }
    let a0 = [0, 0];
    queue.push(a0);
    while (queue.length > 0) {
        let a = queue.shift();
        let j = a[0];
        let i = a[1];
        if (j < 0 || j >= m || i < 0 || i >= n || visited[j][i] || countDight(j, i) > k) {
            continue;
        } 
        visited[j][i] = true;
        let a1 = [j + 1, i];
        let a2 = [j, i + 1];
        queue.push(a1);
        queue.push(a2);
        count++;
    }
    return count;
};

var countDight = function(j, i) {
    let sum = 0;
    while (j != 0) {
        sum += Math.floor(j % 10);
        j = Math.floor(j / 10);
    }
    while (i != 0) {
        sum += Math.floor(i % 10);
        i = Math.floor(i / 10);
    }     
    return sum;
}
```